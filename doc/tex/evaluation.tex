%!TEX root = ../project.tex
\part{Evaluation}

% TODO:
% 	Did it meet its goals?
% 	Why not?
% 	(Don't say ran out of time)
%
%	Break requirements into input, processing, output
% 	Split evaluation into:
% 		Effectiveness
% 		Usability
% 		Maintainability
%
%	Report on:
%		Has each requirement been met?
%			(don't say no time or too hard)
%		If not what has been met and why
%		Talk to end user
%
%
% DO WRITE GOOD

\section{Effectiveness}
%	Effectiveness:
%		Talk about how well I met each target
%		Overall how effective is it?
%		I need to determine the criteria for this
%		A complete evaluation including:
%			Planning
%			Planning time
%			Execution time
%			Your own criteria 
\subsection{Comparison of objectives against finished system}
\begin{tabular}{p{0.1\textwidth}p{0.45\textwidth}p{0.45\textwidth}}
	No. & Original Objective & Completed System \\\hline
	1 & The system should give a clear visualisation of Kepler's Laws &
	Partially completed. The system will show the orbits of the planets, and
	thus show Kepler's laws but there is nothing additional to give clear
	visualisations of them.\\
	2 & The system should allow the user to edit certain parameters &
	Partially completed. The systems lets the user add bodies with different
	parameters (although not the eccentricity directly), but they cannot be
	edited once they have been added. \\
	3 & The system should have a small learning curve & \\
	4 & Both students and teachers should be able to use the system & \\
	5 &The system needs to run smoothly on the school computers & Completed,
	the simulation will run at 60 frames per second, as long as there is a
	reasonable number of bodies in the system.\\
	6 & The system needs to be very easy to use & Partially Completed. There
	is very few different function to learn to use, but deciding what values
	to use when adding a body can be confusing.\\
\end{tabular}

\section{Usability}
The system is very easy to use. It has very few different buttons and everything
is available on the main screen (You don't have to press buttons to get to other
buttons). There is very little latency while performing the main functions of
the system, unless too many bodies have been added to the simulation, in which
case it can start to struggle to process it all. There is always a way to exit
the system available, so the user shouldn't have problems closing the problem.
However if they use the exit button provided by windows they may have to close
the two windows separately.
\subsection{Learnability}
Overall, my system is relatively easy to learn. There is only 3 main function of
the system, and they are mostly very easy to learn. The add body function is the
hardest to learn, as the values it takes can be odd and hard to get right. The
remove body function is just selecting a body to remove and clicking remove. The
save and load function is similarly easy.
%	Learnability:
%		How easy is your system to learn?
%		Include examples
%		Comment on design and UI
%		Make up excuses as to why it sucks
%			(not just that I couldn't get it to work
%
%	Usability:
%		Easy to use - high usability
%		focuses on HCI
%		Target acquisition time
%			ID = log_2(2A/W)
%			ID = index of difficulty
%			A = Distance to move
%			W = size of target
%		Latency
%			How long does it take to do things?
%			Does it let the user know its loading?
%		Metaphors - pictures to guide users
%		How easy is it to navigate?
\subsection{Readability}
My program doesn't have any extra functionality to help users with impaired
vision, but if they have set up their operating system to be more readable it
should also apply to my program. My program doesn't have any large amounts of
text to read, and the main window is just black with colourful circles on top,
which should be easy to see.
%		Readability
%			High contrast?
%			Large fonts
%			Clearly displayed
%			Not too much extra info
%		Ability to reverse/confirm certain actions
%		A way out?

\subsection{Navigating the system}
Navigating the system is very easy because there is only two different windows,
which are both open all the time that the system is running. The menu window
doesn't have any sub-menus within it, so the user won't have problems finding
the buttons that they want.

\section{Maintainability}
\subsection{Adding new features}
Lisp generally makes it easy to write very extendible programs. While I haven't
added functionality for people who want to add to my program, it should be easy
to modify. Some things that users may want to add, like the ability to add moons
to the planets, would require quite a lot of changes to the core of the program,
but the way I have coded it should accommodate this.

\subsection{Fixing Bugs}
During my testing I found that most of the bugs could be fixed by adding handler
cases, and telling the system what to do when it encounters certain errors. I
expect there to be more of these that I have not found, which could also be
fixed easily.

\subsection{Changing Parameters}
Changing certain parameters within the system should be very easy. A lot of
parameters can be edited from within the system. The size of the simulation
window is stored as a global variable in the program, which could be changed
easily.
%	Maintainability:
%			Bug fixing
%			Changing parameters
%			New requirements
%		How easy are these to do?
%			Is the software modular?
%			Is there independent units
%			Self documenting code?
%			Entry and exit points in code
%			Minimal global use
%		Evaluating maintenance document
